---
title: "Project_1"
author: "Tatiana Maslikova"
date: "30 10 2019"
output: 
  html_document:
    df_print: "kable"
---

```{r setup, include=FALSE, warning = FALSE, comment=''}
knitr::opts_chunk$set(echo = FALSE)
```

### 1) Пользовательска функция для объединения наблюдений в единую таблицу
Для объединения данных от нескольких наблюдателей в одну общую таблицу была написана функция `combine_csv()`.
```{r, message=FALSE, echo=TRUE, warning=FALSE}
combine_csv <- function(my_path = '.'){
  library(plyr)
  library(reshape)
  filenames <- list.files(path= my_path, full.names=TRUE)
  import.list <- llply(filenames, read.csv)
  data <- merge_recurse(import.list)
}
```
Аргумент функции `path` - путь до директории,в которой находятся файлы, которые необходимо объединить в один датафрейм. Функция объединит все файлы расширения `.csv`, находящиеся в данной директории.

```{r, include=FALSE}
using<-function(...) {
  libs<-unlist(list(...))
  req<-unlist(lapply(libs,require,character.only=TRUE))
  need<-libs[req==FALSE]
  if(length(need)>0){ 
    install.packages(need)
    lapply(need,require,character.only=TRUE)
  }
}
using('data.table', 'dplyr', 'ggplot2', 'reshape')
df <- combine_csv('~/BI/Stat_R_BI_hw/Data')
len_df_with_NA <- nrow(df)
```

### 2) Предобработка данных
После просмотра структуры данных становится понятно, что у некоторых переменных некорректно задан их тип.
```{r, include = FALSE} 
str(df)
```
Переменная `Rings` отражает количество колец у улитки, а переменная `Length` - длину улитки, но в датасете эти переменные соответсвуют типу `character`. Эти количественные по своей сути переменные были приведены к типу `numeric`.
```{r, include = FALSE}
df$Rings <- as.numeric(df$Rings)
df$Length <- as.numeric(df$Length)
```
Так же в новую переменную `Lenght_z_scores` были сохранены значения переменной `Length` после её стандартизации *(пункт 6 из задания)*
```{r, include=FALSE}
df$Lenght_z_scores <- c(scale(df$Length))
```

Переменная `Sex` по умолчанию текстовая (тип `character`), но её значения соответсвуют цифрам, что подразумевает факторность (в заголовке переменной описано соответствие цифры полу особи). Однако, при переводе переменной в фактор оказывается, что уровня у фактора не 3, как ожидалось (`"female", "uvenil", "male"`), а 6:
```{r, echo=FALSE, comment=''}
levels(as.factor(df$Sex..1...male..2...female..3...uvenil.))
```
Так как по сути тут всего три уровня, переменная была риведена к факторному виду с тремя уровнями: `"male", "female", "uvenil"`.
```{r, include=FALSE}
#df$Sex <- factor(x = df$Sex..1...male..2...female..3...uvenil., levels = c('1', '2', '3', 'male', 'one', 'three'), labels = c('1', '2', '3', '1', '1', '3'))
#df$Sex <- revalue(df$Sex, c("1"="male", "2"="female", "3" = "uvenil"))
df$Sex <- factor(x = df$Sex..1...male..2...female..3...uvenil., levels = c('1', '2', '3', 'male', 'one', 'three'), labels = c('male', 'female', 'uvenil', 'male', 'male', 'uvenil'))
#Старый столбец удаляем
df$Sex..1...male..2...female..3...uvenil. <- NULL
str(df)
```

```{r, include=FALSE}
pMiss <- function(x){sum(is.na(x))/length(x)*100}
apply(df,2,pMiss)
df <- na.omit(df)
len_df_without_NA <- nrow(df)
```
У всех переменных, кроме количества колец, имеются пропущенные значения. Такие наблюдения были выброшены из общей таблицы, т.к. они составляют крайне малый процент от всех наблюдений (`r round(100 - len_df_without_NA * 100 / len_df_with_NA, 1)`%).


### 3) Статистики длины моллюсков разного пола.
```{r, warning = FALSE, comment=''}
df %>% group_by(Sex) %>% 
  dplyr::summarise(mean = mean(Length, na.rm = TRUE), sd = sd(Length, na.rm = TRUE), n = n())
```

### 4) У какого процента моллюсков значение переменной Height не превышает 0.165?
```{r, echo=FALSE, comment=''}
perc = nrow(subset(df, Height >= 0.165))*100/nrow(df)
```
У `r round(perc, 1)`% моллюсков высота не превышает 0.165.

### 5) Чему равняется значение переменной Length, которое выше чем у 92% от всех наблюдений?
```{r}
len_over <- sort(df$Length)[round(length(df$Length)*0.92, 0)]
```
Pначение переменной Length, которое выше чем у 92% от всех наблюдений, не меньше `r len_over`

### 7) Сравнение диаметра моллюсков с числом колец 5 и 15. 
```{r, comment=''}
rings_stats <- df %>% filter(Rings == 5 | Rings == 15) %>% group_by(Rings) %>% 
  dplyr::summarise(mean= mean(Diameter), sd = sd(Diameter), n = n())
n_len <- c(rings_stats[2,2]/rings_stats[1,2])[[1]]
rings_stats
```
Согласно информации из таблицы, средний диаметр моллюсков с 5 кольцами отличается от такового у моллюсков с 15 кольцами в `r round(n_len, 1)`  раза.

```{r}
rings <- subset(df, Rings == 5 | Rings == 15)
my_test <- t.test(subset(df, Rings == 5)$Diameter, subset(df, Rings == 15)$Diameter)
```
Чтобы выбрать статистический тест для проверки значимости этих результатов необходимо проверить данные на нормальность рапсределения. Согласно тесту нормальности Шапиро-Уилка, величины диаметра панциря с 5 кольцами и с 15 кольцами распределены нормально (p-value = `r round(shapiro.test(subset(df, Rings == 5)$Diameter)$p.value, 2)` > 0,05 для 5 колец, и p-value = `r round(shapiro.test(subset(df, Rings == 15)$Diameter)$p.value, 2)` > 0,05 для 15 колец), а значит можно применить t-тест.
```{r, warning = FALSE}
ggplot(rings, aes(x = Diameter))+
  geom_density(fill = 'blue', alpha = 0.5) +
  facet_grid(cols = vars(Rings), ) +
  labs(x = 'Диаметр панциря', y = 'Плотность распределения') +
  theme_light()
```


Cогласно t-тесту диаметры раковин с разным количеством колец (5 и 15) достоверно различаются (p-value = `r my_test$p.value`; значение t-статистики: `r round(my_test$statistic,0)`; количество степеней свободы: `r round(my_test$parameter, 0)`).


```{r}
ggplot(rings, aes(x = as.factor(Rings), y = Diameter )) +
  geom_boxplot(fill = 'green', alpha = 0.5, outlier.colour = "red") +
  labs(x = 'Количество колец', y = 'Диаметр раковины', title = 'Результаты сравнения диаметра раковин с 5 и 15 кольцами') +
  theme_light()
```

### 8) Анализ и взаимосвязь диаметра ракушки и общего веса
#### Анализ диаметра панциря улитки
Минимальный диаметр ракушки у улиток `r min(df$Diameter, na.rm = TRUE)`, а максимальный `r round(max(df$Diameter, na.rm = TRUE), 3)`. Дисперсия данного признака равна `r round(sd(df$Diameter, na.rm = TRUE), 3)`. Согласно тесту нормальности Шапиро-Уилка, данная величина не распределена нормально (p-value = `r shapiro.test(df$Diameter)$p.value` < 0,05).
```{r, warning = FALSE}
ggplot(df, aes(x = Diameter))+
  geom_density(color = 'darkblue', fill = 'blue', alpha = 0.5) +
  labs(x = 'Диаметр панциря', y = 'Плотность распределения') +
  theme_light()
```

#### Анализ веса улиток
Минимальный вес ракушки у улиток `r min(df$Whole_weight, na.rm = TRUE)`, а максимальный `r max(df$Whole_weight, na.rm = TRUE)`. Дисперсия данного признака равна `r round(sd(df$Whole_weight, na.rm = TRUE), 3)`. Согласно тесту нормальности Шапиро-Уилка, данная величина не распределена нормально (p-value = `r shapiro.test(df$Whole_weight)$p.value` < 0,05).
```{r, warning = FALSE}
ggplot(df, aes(x = Whole_weight))+
  geom_density(color = 'darkblue', fill = 'blue', alpha = 0.5) +
  labs(x = 'Общий вес', y = 'Плотность распределения') +
  theme_light()
```

#### Оценка взаимосвязи диаметра панциря и веса улиток
```{r}
t_cor <- cor.test(df$Diameter, df$Whole_weight, method = "spearman", na.action = na.omit, exact = FALSE)
```
Так как такие показатели, как диаметр панциря и общий вес, распределены не нормально, для оценки корреляции был использован коэффициент корреляции Спирмена. При p < 0.05 (p-value = `r t_cor$p.value`) была принята гипотеза о том, что между этими характеристиками положительная нелинейная связь (*rho* = `r  round(t_cor$estimate, 3)`), а именно экспоненциальная регрессия.

```{r, message = FALSE, warning = FALSE}
ggplot(df, aes(Diameter, Whole_weight)) +
  geom_point(color = 'purple') +
  geom_smooth(color = 'darkred', fill = 'yellow') +
  labs(x = 'Диаметр панциря', y = 'Общий вес улитки', title = 'Экспоненциальная регрессия диаметра панциря и веса улитки') +
  theme_light()
```

```{r, message = FALSE, warning = FALSE}
ggplot(df, aes(log(Diameter), log(Whole_weight))) +
  geom_point(color = 'purple') +
  geom_smooth(color = 'darkred', fill = 'yellow')+
  labs(x = 'ln(Диаметр панциря)', y = 'ln(Общий вес улитки)', title = 'Приведённая к линейному виду корреляция') +
  theme_light()
```

```{r}
lm <- lm(log(Whole_weight)~log(Diameter), data = df)
```
