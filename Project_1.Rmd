---
title: "Project_1"
author: "Tatiana Maslikova"
date: "30 10 2019"
output: 
  html_document:
    df_print: "kable"
---

```{r setup, include=FALSE, warning = FALSE, comment=''}
knitr::opts_chunk$set(echo = FALSE)
```

### 1) Пользовательска функция для объединения наблюдений в единую таблицу
Для объединения данных от нескольких наблюдателей в одну общую таблицу была написана функция `combine_csv()`. 
```{r, message=FALSE, echo=TRUE}
combine_csv <- function(my_path = '.'){
  library(dplyr)
  library(data.table)
  files <-  list.files(path = my_path, pattern="*.csv")
  df <- do.call(rbind, lapply(files, fread))
}
```
Аргумент функции `path` - путь до директории,в которой находятся файлы, которые необходимо объединить в один датафрейм. Функция объединит все файлы расширения `.csv`, находящиеся в данной директории.

```{r, include=FALSE}
using<-function(...) {
  libs<-unlist(list(...))
  req<-unlist(lapply(libs,require,character.only=TRUE))
  need<-libs[req==FALSE]
  if(length(need)>0){ 
    install.packages(need)
    lapply(need,require,character.only=TRUE)
  }
}

using('data.table', 'dplyr', 'ggplot2')
df <- combine_csv('~/BI/Stat_R_BI_hw/Data')
```

### 2) Предобработка данных
После просмотра структуры данных становится понятно, что у некоторых переменных некорректно задан их тип.
```{r, include = FALSE} 
str(df)
```
Переменная `Rings` отражает количество колец у улитки, а переменная `Length` - длину улитки, но в датасете эти переменные соответсвуют типу `character`. Эти количественные по своей сути переменные были приведены к типу `numeric`.
```{r, include = FALSE}
df
df$Rings <- as.numeric(df$Rings)
df$Length <- as.numeric(df$Length)
```
Так же в новую переменную `Lenght_z_scores` были сохранены значения переменной `Length` после её стандартизации *(пункт 6 из задания)*
```{r, include=FALSE}
df$Lenght_z_scores <- c(scale(df$Length))
```

Переменная `Sex` по умолчанию текстовая (тип `character`), но её значения соответсвуют цифрам, что подразумевает факторность (в заголовке переменной описано соответствие цифры полу особи). Однако, при переводе переменной в фактор оказывается, что уровня у фактора не 3, как ожидалось (`"female", "uvenil", "male"`), а 6:
```{r, echo=FALSE}
str(as.factor(df$`Sex (1 – male, 2 – female, 3 – uvenil)`))
```
Так как по сути тут всего три уровня, переменная была риведена к факторному виду с тремя уровнями: `"male", "female", "uvenil"`.
```{r, include=FALSE}
df$Sex <- factor(x = df$`Sex (1 – male, 2 – female, 3 – uvenil)`, levels = c('1', '2', '3', 'male', 'one', 'three'), labels = c('male', 'female', 'uvenil', 'male', 'male', 'uvenil'))
#Старый столбец удаляем
df$`Sex (1 – male, 2 – female, 3 – uvenil)` <- NULL
```

### 3) Статистики длины моллюсков разного пола.
```{r, warning = FALSE, comment=''}
df %>% group_by(Sex) %>% 
  summarise(mean = mean(Length, na.rm = TRUE), sd = sd(Length, na.rm = TRUE)) %>%
  filter(!is.na(Sex))
```

### 4) У какого процента моллюсков значение переменной Height не превышает 0.165?
```{r, echo=FALSE, comment=''}
perc = nrow(subset(df, Height >= 0.165))*100/nrow(df)
```
У `r round(perc, 1)`% моллюсков высота не превышает 0.165.

### 5) Чему равняется значение переменной Length, которое выше чем у 92% от всех наблюдений?
```{r}
len_over <- sort(df$Length)[round(length(df$Length)*0.92, 0)]
```
Pначение переменной Length, которое выше чем у 92% от всех наблюдений, не меньше `r len_over`

### 7) Сравнение диаметра моллюсков с числом колец 5 и 15. 
```{r, comment=''}
rings_stats <- df %>% filter(Rings == 5 | Rings == 15) %>% group_by(Rings) %>% 
  summarise(mean= mean(Diameter), sd = sd(Diameter), n = n())
n_len <- c(rings_stats[2,2]/rings_stats[1,2])[[1]]
rings_stats
```
Согласно информации из таблицы, средний диаметр моллюсков с 5 кольцами отличается от такового у моллюсков с 15 кольцами в `r round(n_len, 1)`  раза.

```{r}
rings <- subset(df, Rings == 5 | Rings == 15)
my_test <- t.test(subset(df, Rings == 5)$Diameter, subset(df, Rings == 15)$Diameter)
```
Для проверки статистической значимости этих результатов был применён т-тест, согласно которому диаметры раковин с разным кличеством колец (5 и 15) достоверно различаются (p-value = `r my_test$p.value`; значение t-статистики: `r round(my_test$statistic,0)`; количество степеней свободы: `r round(my_test$parameter, 0)`).


```{r}
ggplot(rings, aes(x = as.factor(Rings), y = Diameter )) +
  geom_boxplot(outlier.colour = "red") +
  labs(x = 'Количество колец', y = 'Диаметр раковины', title = 'Результаты сравнения диаметра раковин с 5 и 15 кольцами')
```

### 8) Анализ и взаимосвязь диаметра ракушки и общего веса
#### Анализ диаметра панциря улитки
Минимальный диаметр ракушки у улиток `r min(df$Diameter, na.rm = TRUE)`, а максимальный `r round(max(df$Diameter, na.rm = TRUE), 3)`. Дисперсия данного признака равна `r round(sd(df$Diameter, na.rm = TRUE), 3)`. Согласно тесту нормальности Шапиро-Уилка, данная величина не распределена нормально (p-value = `r shapiro.test(df$Diameter)$p.value` < 0,05, а значит нулевая гипотеза, согласно которой величина рапсределена нормально, отвергается).
```{r, warning = FALSE}
ggplot(df, aes(x = Diameter))+
  geom_density() +
  labs(x = 'Диаметр панциря', y = 'Плотность распределения')
```

#### Анализ веса улиток
Минимальный вес ракушки у улиток `r min(df$Whole_weight, na.rm = TRUE)`, а максимальный `r max(df$Whole_weight, na.rm = TRUE)`. Дисперсия данного признака равна `r sd(df$Whole_weight, na.rm = TRUE)`. Дисперсия данного признака равна `r round(sd(df$Whole_weight, na.rm = TRUE), 3)`. Согласно тесту нормальности Шапиро-Уилка, данная величина не распределена нормально (p-value = `r shapiro.test(df$Whole_weight)$p.value` < 0,05, а значит нулевая гипотеза, согласно которой величина рапсределена нормально, отвергается).
```{r, warning = FALSE}
ggplot(df, aes(x = Whole_weight))+
  geom_density() +
  labs(x = 'Общий вес', y = 'Плотность распределения')
```

#### Оценка взаимосвязи диаметра панциря и веса улиток
```{r}
t_cor <- cor.test(df$Diameter, df$Whole_weight, method = "spearman", na.action = na.omit, exact = FALSE)
```
Так как такие показатели, как диаметр панциря и общий вес, рапсределены не нормально, для оценки корреляции был использован коэффициент корреляции Спирмена. При p < 0.05 (p-value = `r t_cor$p.value`) была принята гипотеза о том, что между этими характеристиками положительная нелинейная связь (*rho* = `r  round(t_cor$estimate, 3)`)

```{r, warning = FALSE}
ggplot(df, aes(Diameter, Whole_weight)) +
  geom_point() +
  labs(x = 'Диаметр панциря', y = 'Общий вес улитки', title = 'Корреляция между диаметром панциря и весом улитки')
```
